<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ComptabiliteManagerImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">myerp-business</a> &gt; <a href="index.source.html" class="el_package">com.dummy.myerp.business.impl.manager</a> &gt; <span class="el_source">ComptabiliteManagerImpl.java</span></div><h1>ComptabiliteManagerImpl.java</h1><pre class="source lang-java linenums">package com.dummy.myerp.business.impl.manager;

import java.math.BigDecimal;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Set;
import javax.validation.ConstraintViolation;
import javax.validation.ConstraintViolationException;

import com.dummy.myerp.model.bean.comptabilite.*;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.transaction.TransactionStatus;
import com.dummy.myerp.business.contrat.manager.ComptabiliteManager;
import com.dummy.myerp.business.impl.AbstractBusinessManager;
import com.dummy.myerp.technical.exception.FunctionalException;
import com.dummy.myerp.technical.exception.NotFoundException;


/**
 * Comptabilite manager implementation.
 */

public class ComptabiliteManagerImpl extends AbstractBusinessManager implements ComptabiliteManager {

    // ==================== Attributs ====================


    // ==================== Constructeurs ====================
    /**
     * Instantiates a new Comptabilite manager.
     */
<span class="fc" id="L34">    public ComptabiliteManagerImpl() {</span>
<span class="fc" id="L35">    }</span>


    // ==================== Getters/Setters ====================
    @Override
    public List&lt;CompteComptable&gt; getListCompteComptable() {
<span class="nc" id="L41">        return getDaoProxy().getComptabiliteDao().getListCompteComptable();</span>
    }


    @Override
    public List&lt;JournalComptable&gt; getListJournalComptable() {
<span class="nc" id="L47">        return getDaoProxy().getComptabiliteDao().getListJournalComptable();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;EcritureComptable&gt; getListEcritureComptable() {
<span class="nc" id="L55">        return getDaoProxy().getComptabiliteDao().getListEcritureComptable();</span>
    }

    /**
     * {@inheritDoc}
     */
    // TODO à tester
    @Override
    public synchronized void addReference(EcritureComptable pEcritureComptable)  {
        // TODO à implémenter
<span class="fc" id="L65">        SequenceEcritureComptable vSequenceEcritureComptable = null;</span>
        // Bien se réferer à la JavaDoc de cette méthode !
        /* Le principe :
                1.  Remonter depuis la persitance la dernière valeur de la séquence du journal pour l'année de l'écriture
                    (table sequence_ecriture_comptable)*/
<span class="fc" id="L70">        try { vSequenceEcritureComptable = getDaoProxy().getComptabiliteDao().getSequenceEcritureComptable(</span>
<span class="fc" id="L71">                pEcritureComptable.getJournal().getCode(),</span>
<span class="fc" id="L72">                pEcritureComptable.getDate().getYear());</span>
<span class="nc" id="L73">        } catch (NotFoundException e) {</span>
<span class="nc" id="L74">            e.printStackTrace();</span>
<span class="fc" id="L75">        }</span>

        /*  2.  * S'il n'y a aucun enregistrement pour le journal pour l'année concernée :
                        1. Utiliser le numéro 1.
                    * Sinon :
                        1. Utiliser la dernière valeur + 1 */

<span class="fc bfc" id="L82" title="All 2 branches covered.">        if(vSequenceEcritureComptable == null) {</span>
<span class="fc" id="L83">            Calendar calendar = Calendar.getInstance();</span>
<span class="fc" id="L84">            vSequenceEcritureComptable = new SequenceEcritureComptable(pEcritureComptable.getJournal(),calendar.get(Calendar.YEAR),1);</span>
<span class="fc" id="L85">        } else {</span>
<span class="fc" id="L86">            vSequenceEcritureComptable.setDerniereValeur(vSequenceEcritureComptable.getDerniereValeur() + 1);</span>
        }

        // 3.  Mettre à jour la référence de l'écriture avec la référence calculée (RG_Compta_5)

<span class="fc" id="L91">        String vReferenceFormated = String.format(&quot;%05d&quot;, vSequenceEcritureComptable.getDerniereValeur());</span>
<span class="fc" id="L92">        pEcritureComptable.setReference(vReferenceFormated);</span>

         /* 4.  Enregistrer (insert/update) la valeur de la séquence en persitance
                    (table sequence_ecriture_comptable) */

<span class="fc" id="L97">        getDaoProxy().getComptabiliteDao().updateEcritureComptable(pEcritureComptable);</span>

<span class="fc bfc" id="L99" title="All 2 branches covered.">        if (vSequenceEcritureComptable.getDerniereValeur() == 1) {</span>
<span class="fc" id="L100">            getDaoProxy().getComptabiliteDao()</span>
<span class="fc" id="L101">                    .insertSequenceEcritureComptable(vSequenceEcritureComptable);</span>
        } else {
<span class="fc" id="L103">            getDaoProxy().getComptabiliteDao()</span>
<span class="fc" id="L104">                    .updateSequenceEcritureComptable(vSequenceEcritureComptable);</span>
        }
<span class="fc" id="L106">    }</span>

    /**
     * {@inheritDoc}
     */
    // TODO à tester
    @Override
    public void checkEcritureComptable(EcritureComptable pEcritureComptable) throws FunctionalException {
<span class="fc" id="L114">        this.checkEcritureComptableUnit(pEcritureComptable);</span>
<span class="fc" id="L115">        this.checkEcritureComptableContext(pEcritureComptable);</span>
<span class="fc" id="L116">    }</span>


    /**
     * Vérifie que l'Ecriture comptable respecte les règles de gestion unitaires,
     * c'est à dire indépendemment du contexte (unicité de la référence, exercie comptable non cloturé...)
     *
     * @param pEcritureComptable -
     * @throws FunctionalException Si l'Ecriture comptable ne respecte pas les règles de gestion
     */
    // TODO tests à compléter
    protected void checkEcritureComptableUnit(EcritureComptable pEcritureComptable) throws FunctionalException {
        // ===== Vérification des contraintes unitaires sur les attributs de l'écriture
<span class="fc" id="L129">        Set&lt;ConstraintViolation&lt;EcritureComptable&gt;&gt; vViolations = getConstraintValidator().validate(pEcritureComptable);</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (!vViolations.isEmpty()) {</span>
<span class="fc" id="L131">            throw new FunctionalException(&quot;L'écriture comptable ne respecte pas les règles de gestion.&quot;,</span>
                    new ConstraintViolationException(
                            &quot;L'écriture comptable ne respecte pas les contraintes de validation&quot;,
                            vViolations));
        }
        // ===== RG_Compta_3 : une écriture comptable doit avoir au moins 2 lignes d'écriture (1 au débit, 1 au crédit)
<span class="fc" id="L137">        int vNbrCredit = 0;</span>
<span class="fc" id="L138">        int vNbrDebit = 0;</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        for (LigneEcritureComptable vLigneEcritureComptable : pEcritureComptable.getListLigneEcriture()) {</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">            if (BigDecimal.ZERO.compareTo(ObjectUtils.defaultIfNull(vLigneEcritureComptable.getCredit(),</span>
                    BigDecimal.ZERO)) != 0) {
<span class="fc" id="L142">                vNbrCredit++;</span>
            }
<span class="fc bfc" id="L144" title="All 2 branches covered.">            if (BigDecimal.ZERO.compareTo(ObjectUtils.defaultIfNull(vLigneEcritureComptable.getDebit(),</span>
                    BigDecimal.ZERO)) != 0) {
<span class="fc" id="L146">                vNbrDebit++;</span>
            }
<span class="fc" id="L148">        }</span>

<span class="pc bpc" id="L150" title="2 of 6 branches missed.">        if (pEcritureComptable.getListLigneEcriture().size() &lt; 2</span>
                || vNbrCredit &lt; 1
                || vNbrDebit &lt; 1) {
<span class="fc" id="L153">            throw new FunctionalException(</span>
                    &quot;L'écriture comptable doit avoir au moins deux lignes : une ligne au débit et une ligne au crédit.&quot;);
        }

        // ===== RG_Compta_2 : Pour qu'une écriture comptable soit valide, elle doit être équilibrée
<span class="fc bfc" id="L158" title="All 2 branches covered.">        if (!pEcritureComptable.isEquilibree()) {</span>
<span class="fc" id="L159">            throw new FunctionalException(&quot;L'écriture comptable n'est pas équilibrée.&quot;);</span>
        }

        // TODO ===== RG_Compta_5 : Format et contenu de la référence

        /*	La référence d'une écriture comptable est composée du code du journal dans lequel figure l'écriture suivi de
         l'année et d'un numéro de séquence (propre à chaque journal) sur 5 chiffres incrémenté automatiquement à chaque
         écriture. Le formatage de la référence est : XX-AAAA/#####.
          Ex : Journal de banque (BQ), écriture au 31/12/2016 -&gt; BQ-2016/00001 */

        // vérifier que l'année dans la référence correspond bien à la date de l'écriture, idem pour le code journal...

<span class="fc bfc" id="L171" title="All 2 branches covered.">        if(pEcritureComptable.getReference() != null) {</span>

<span class="fc" id="L173">            String vReference = pEcritureComptable.getReference();</span>
<span class="fc" id="L174">            String[] testReference = vReference.split(&quot;[-/]&quot;);</span>
<span class="fc" id="L175">            Calendar calendar = Calendar.getInstance();</span>
<span class="fc" id="L176">            int annee = calendar.get(Calendar.YEAR);</span>


<span class="fc bfc" id="L179" title="All 2 branches covered.">            if(!testReference[0].equals(pEcritureComptable.getJournal().getCode())) {</span>
<span class="fc" id="L180">                throw new FunctionalException(</span>
<span class="fc" id="L181">                        &quot;Le code journal &quot; + pEcritureComptable.getJournal().getCode() + &quot; ne correspond à celui de la référence &quot;</span>
                                + testReference[0]);
            }

<span class="fc bfc" id="L185" title="All 2 branches covered.">            if(!testReference[1].equals(String.valueOf(annee))) {</span>
<span class="fc" id="L186">                throw new FunctionalException(&quot;L'année de référence ne correspond pas à l'année courante&quot;);</span>
            }

            try {
<span class="fc" id="L190">                SequenceEcritureComptable vSequenceEcritureComptable = getDaoProxy().getComptabiliteDao()</span>
<span class="fc" id="L191">                        .getSequenceEcritureComptable(</span>
<span class="fc" id="L192">                                pEcritureComptable.getJournal().getCode(),</span>
<span class="fc" id="L193">                                pEcritureComptable.getDate().getYear());</span>

<span class="fc bfc" id="L195" title="All 2 branches covered.">                if(!testReference[2].equals(String.valueOf(String.format(&quot;%05d&quot;, vSequenceEcritureComptable.getDerniereValeur())))){</span>
<span class="fc" id="L196">                     throw new FunctionalException(&quot;Le numéro de séquence de la référence&quot;</span>
<span class="fc" id="L197">                            + vSequenceEcritureComptable.getDerniereValeur() +</span>
                             &quot; ne correspond pas pas à la dernière séquence du journal : &quot;
                             + testReference[2]);
                }
<span class="nc" id="L201">            } catch (NotFoundException e) {</span>
<span class="nc" id="L202">                System.err.println(&quot;La séquence d'écriture comptable n'existe pas.&quot;);</span>
<span class="fc" id="L203">            }</span>


        }

<span class="fc bfc" id="L208" title="All 2 branches covered.">        if(pEcritureComptable.getReference() == null)</span>
<span class="fc" id="L209">            throw new FunctionalException(&quot;La référence de l'écriture comptable ne peut pas être nulle&quot;);</span>
<span class="fc" id="L210">    }</span>


    /**
     * Vérifie que l'Ecriture comptable respecte les règles de gestion liées au contexte
     * (unicité de la référence, année comptable non cloturé...)
     *
     * @param pEcritureComptable -
     * @throws FunctionalException Si l'Ecriture comptable ne respecte pas les règles de gestion
     */
    protected void checkEcritureComptableContext(EcritureComptable pEcritureComptable) throws FunctionalException {
        // ===== RG_Compta_6 : La référence d'une écriture comptable doit être unique
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        if (StringUtils.isNoneEmpty(pEcritureComptable.getReference())) {</span>
            try {
                // Recherche d'une écriture ayant la même référence
<span class="fc" id="L225">                EcritureComptable vECRef = getDaoProxy().getComptabiliteDao().getEcritureComptableByRef(</span>
<span class="fc" id="L226">                        pEcritureComptable.getReference());</span>

                // Si l'écriture à vérifier est une nouvelle écriture (id == null),
                // ou si elle ne correspond pas à l'écriture trouvée (id != idECRef),
                // c'est qu'il y a déjà une autre écriture avec la même référence
<span class="fc bfc" id="L231" title="All 2 branches covered.">                if (pEcritureComptable.getId() == null</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">                        || !pEcritureComptable.getId().equals(vECRef.getId())) {</span>
<span class="fc" id="L233">                   throw new FunctionalException(&quot;Une autre écriture comptable existe déjà avec la même référence.&quot;);</span>
                }
<span class="nc" id="L235">            } catch (NotFoundException vEx) {</span>
                // Dans ce cas, c'est bon, ça veut dire qu'on n'a aucune autre écriture avec la même référence.
<span class="fc" id="L237">            }</span>
        }
<span class="fc" id="L239">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void insertEcritureComptable(EcritureComptable pEcritureComptable) throws FunctionalException {
<span class="fc" id="L246">        this.checkEcritureComptable(pEcritureComptable);</span>
<span class="fc" id="L247">        TransactionStatus vTS = getTransactionManager().beginTransactionMyERP();</span>
        try {
<span class="fc" id="L249">            getDaoProxy().getComptabiliteDao().insertEcritureComptable(pEcritureComptable);</span>
<span class="fc" id="L250">            getTransactionManager().commitMyERP(vTS);</span>
<span class="fc" id="L251">            vTS = null;</span>
        } finally {
<span class="fc" id="L253">            getTransactionManager().rollbackMyERP(vTS);</span>
        }
<span class="fc" id="L255">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void updateEcritureComptable(EcritureComptable pEcritureComptable) throws FunctionalException {
<span class="fc" id="L262">        this.checkEcritureComptable(pEcritureComptable);</span>
<span class="fc" id="L263">        TransactionStatus vTS = getTransactionManager().beginTransactionMyERP();</span>
        try {
<span class="fc" id="L265">            getDaoProxy().getComptabiliteDao().updateEcritureComptable(pEcritureComptable);</span>
<span class="fc" id="L266">            getTransactionManager().commitMyERP(vTS);</span>
<span class="fc" id="L267">            vTS = null;</span>
        } finally {
<span class="fc" id="L269">            getTransactionManager().rollbackMyERP(vTS);</span>
        }
<span class="fc" id="L271">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void deleteEcritureComptable(Integer pId) {
<span class="fc" id="L278">        TransactionStatus vTS = getTransactionManager().beginTransactionMyERP();</span>
        try {
<span class="fc" id="L280">            getDaoProxy().getComptabiliteDao().deleteEcritureComptable(pId);</span>
<span class="fc" id="L281">            getTransactionManager().commitMyERP(vTS);</span>
<span class="fc" id="L282">            vTS = null;</span>
        } finally {
<span class="fc" id="L284">            getTransactionManager().rollbackMyERP(vTS);</span>
        }
<span class="fc" id="L286">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>